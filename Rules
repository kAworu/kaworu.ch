#!/usr/bin/env ruby
require 'time'
require 'compass'

Compass.add_project_configuration 'compass_config.rb'

preprocess do
 # setup the previous/next links
  def setup_previous_next_nav(items)
    first, last = 0, (items.length - 1)
    items.each_with_index do |item, i|
      item[:previous] = items[i - 1].identifier if i > first
      item[:next]     = items[i + 1].identifier if i < last
    end
  end

  # setup some items for tags pages
  def generate_tag_pages_items
    # build a Hash like {'tagname' => [article1, article0], ...}
    sorted_articles.inject Hash.new do |injected, article|
      article_tags = article[:tags] || Array.new
      article_tags.each { |tag| (injected[tag] ||= Array.new) << article }
      injected
    end.each do |tag, articles|
      @items.create(
        "<%= render '/_blog_archives.*', articles: @item[:articles].map { |id| @items[id] } %>",
        {
          navbar: 'Archives',
          title: "Tag: #{tag}",
          kind: 'tag-archive',
          tag: tag,
          articles: articles.map(&:identifier)
        },
        "/blog/tags/#{tag}" # FIXME: slugize ?
      )
    end
  end

  # inspired by http://nanoc.ws/docs/guides/paginating-articles/
  def generate_blog_pages_items
    slices = sorted_articles.each_slice(@config[:paginate])
    slices.each_with_index.inject Array.new do |result, each|
      subarticles, i = each
      @items.create(
        "<%= render '/_blog_page.*', articles: @item[:articles].map { |id| @items[id] } %>",
        {
          navbar: 'Blog',
          kind: 'blog-page',
          no_page_header: true,
          articles: subarticles.map(&:identifier),
        },
        if i.zero? then "/index.html" else "/blog/page/#{i + 1}" end
      )
    end
  end

  generate_tag_pages_items
  generate_blog_pages_items
  setup_previous_next_nav sorted_articles.reverse
  setup_previous_next_nav blog_pages.reverse
end

# favicon
passthrough '/favicon.*'

# some exceptional files
%w[/sitemap.* /robots.* /humans.* /atom.*].each do |f|
    compile f do
        filter :erb
    end
end

# stylesheets

ignore '/style/**/_*' # partials
compile '/style/screen.scss' do
  filter :sass, Compass.sass_engine_options
  filter :relativize_paths, :type => :css
end

route '/style/**/*' do
  item.identifier.without_ext + '.css'
end

# blog
compile '/blog/articles/**/*' do
  if item[:extension] =~ /^md|mkd|markdown$/
    filter :kramdown
  elsif item[:extension] == 'haml'
    filter :haml
  else # default filter
    filter :erb
  end
  filter :octohl
  layout '/article.*'
  layout '/default.*'
end
route '/blog/articles/**/*' do # /blog/articles/foo.html/ â†’ /blog/1970/01/01/foo.html
    t = attribute_to_time item[:created_at]
    "/blog/#{t.strftime '%Y/%m/%d'}/#{File.basename item.identifier.without_ext}/index.html"
end

# static stuff
compile '/static/**/*' do
end

route '/static/**/*' do
  item.identifier.to_s
end

# "default" rule
#
compile '/**/*' do
  if item[:extension] == 'css' || item.binary?
    # do nada
  else
    filter :erb
    filter :octohl
    layout '/page.*'
    layout '/default.*'
  end
end

route '/**/index.html' do
  item.identifier.to_s
end

route '/**/*.html' do
  item.identifier.without_ext + '/index.html'
end

route '/**/*' do
  if item[:extension] == 'css' or item.binary?
    item.identifier.to_s
  elsif item[:path]
    item[:path]
  else
    item.identifier.without_ext + '/index.html'
  end
end

layout '/**/*', :erb
