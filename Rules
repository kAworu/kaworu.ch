#!/usr/bin/env ruby
require 'time'
require 'compass'

Compass.add_project_configuration 'compass_config.rb'

preprocess do
  # Link the all the given items in order in a doubly linked list.
  #
  # The previous and next item identifier are stored in item[:navigation_prev]
  # and item[:navigation_next] respectively.
  #
  # see navigation_prev() and navigation_next()
  def setup_previous_next_nav(items)
    first, last = 0, (items.length - 1)
    items.each_with_index do |item, i|
      item[:navigation_prev] = items[i - 1].identifier if i > first
      item[:navigation_next] = items[i + 1].identifier if i < last
    end
  end

  # setup some items for tags pages
  def generate_tag_pages_items
    # build a Hash like {'tagname' => [article1, article0], ...}
    sorted_articles.inject Hash.new do |injected, article|
      article_tags = article[:tags] || Array.new
      article_tags.each { |tag| (injected[tag] ||= Array.new) << article }
      injected
    end.each do |tag, articles|
      @items.create(
        "<%= render '/_blog_archives.html', articles: @item[:article_ids].map { |id| @items[id] } %>",
        {
          navbar: 'Archives',
          title: "Tag: #{tag}",
          kind: 'tag-archive',
          tag: tag,
          article_ids: articles.map(&:identifier)
        },
        "/blog/tags/#{tag}" # FIXME: slugize ?
      )
    end
  end

  # inspired by http://nanoc.ws/docs/guides/paginating-articles/
  def generate_blog_pages_items
    slices = sorted_articles.each_slice(@config[:paginate])
    slices.each_with_index do |subarticles, i|
      @items.create(
        "<%= render '/_blog_page.html', articles: @item[:article_ids].map { |id| @items[id] } %>",
        {
          navbar: 'Blog',
          kind: 'blog-page',
          no_page_header: true,
          article_ids: subarticles.map(&:identifier),
        },
        if i.zero? then "/index.html" else "/blog/page/#{i + 1}" end
      )
    end
  end

  generate_tag_pages_items
  generate_blog_pages_items
  setup_previous_next_nav sorted_articles.reverse
  setup_previous_next_nav blog_pages.reverse
end

layout '/**/*', :erb

# favicon
passthrough '/favicon.*'

# some exceptional files
%w[/sitemap.xml /robots.txt /humans.txt /atom.xml].each do |f|
    compile f do
        filter :erb
    end
end

# stylesheets
ignore '/style/**/_*' # partials
compile '/style/screen.scss' do
  filter :sass, Compass.sass_engine_options
  filter :relativize_paths, :type => :css
end
# /style/foo.scss → /style/foo.css
route '/style/**/*' do
  item.identifier.without_ext + '.css'
end

# blog
compile '/blog/articles/**/*' do
  filter :erb
  filter :octohl
  layout '/article.html'
  layout '/default.html'
end
# /blog/articles/foo.html → /blog/1970/01/01/foo/index.html
route '/blog/articles/**/*' do
    t = attribute_to_time item[:created_at]
    name = File.basename item.identifier.without_ext
    "/blog/#{t.strftime '%Y/%m/%d'}/#{name}/index.html"
end

# static stuff
compile '/static/**/*' do
end
# /static/foo.bar → /static/foo.bar
route '/static/**/*' do
  item.identifier.to_s
end

# "default" rule
compile '/**/*' do
  unless item.binary?
    filter :erb
    filter :octohl
    layout '/page.html'
    layout '/default.html'
  end
end
# /foo/bar/index.html → /foo/bar/index.html
route '/**/index.html' do
  item.identifier.to_s
end
# /foo.bin → /foo.bin
# /foo/bar/oni.html → /foo/bar/oni/index.html
# + special cases handling for item having a path attribute set.
route '/**/*' do
  if item.binary?
    item.identifier.to_s
  elsif item[:path]
    item[:path]
  else
    item.identifier.without_ext + '/index.html'
  end
end
